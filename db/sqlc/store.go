package db

import (
	"database/sql"
)

type Store interface {
	// TODO: add functions to this interface
	Querier
	// InsertBookTx(ctx context.Context, arg InsertBookTxParams) (InsertBookTxResult, error)
}

type SQLStore struct {
	*Queries
	// this object is used to create a new db transaction.
	db *sql.DB
}

//Although we have changed the Store type from struct to interface, our code will still work well,
//and we don’t have to change anything in the main.go file because the db.NewStore() function
//is now also returning a Store interface with the actual implementation SQLStore that connects to the real SQL DB

func NewStore(db *sql.DB) Store {
	// The New() function was generated by sqlc as we’ve already known in the previous lectures. It creates and returns a Queries object.
	//why Store -> return &SQLStore
	return &SQLStore{
		db:      db,
		Queries: New(db),
	}
}

//execTx executes a function within a database transaction
//this function is unexported (it starts with a lowercase letter e), because we don’t want external package to call it directly. Instead, we will provide an exported function for each specific transaction.

// func (store *SQLStore) execTx(ctx context.Context, fn func(*Queries) error) error {
// 	tx, err := store.db.BeginTx(ctx, &sql.TxOptions{})
// 	if err != nil {
// 		return err
// 	}
// 	q := New(tx)
// 	err = fn(q)
// 	if err != nil {
// 		if rbErr := tx.Rollback(); rbErr != nil {
// 			return fmt.Errorf("tx err: %v, rb err: %v", err, rbErr)
// 		}
// 		return err
// 	}
// 	return tx.Commit()
// }

// type InsertBookTxParams struct {
// 	Bookname    string        `json:"bookname"`
// 	Publishdate time.Time     `json:"publishdate"`
// 	Price       int64         `json:"price"`
// 	Pid         sql.NullInt64 `json:"pid"`
// 	Eid         sql.NullInt64 `json:"eid"`
// 	Category    string        `json:"category"`
// 	Author      string        `json:"author"`
// 	Type        string        `json:"type"`
// }

// type InsertBookTxResult struct {
// 	Book     interface{} `json:"book"`
// 	Category Category    `json:"categor"`
// 	Author   Author      `json:"author"`
// 	BookType interface{} `json:"child_book"`
// }

// func (store *SQLStore) InsertBookTx(ctx context.Context, arg InsertBookTxParams) (InsertBookTxResult, error) {
// 	var result InsertBookTxResult
// 	err := store.execTx(ctx, func(q *Queries) error {
// 		book, err := q.CreateBook(ctx, CreateBookParams{
// 			Bookname:    arg.Bookname,
// 			Publishdate: arg.Publishdate,
// 			Price:       arg.Price,
// 			Pid:         arg.Pid,
// 			Eid:         arg.Eid,
// 		})
// 		result.Book = &book
// 		if err != nil {
// 			return err
// 		}
// 		if strings.ToLower(arg.Type) == "audiobook" {
// 			result.BookType, err = q.CreateAudioBook(ctx, book.Boid)
// 			if err != nil {
// 				return err
// 			}
// 		} else if strings.ToLower(arg.Type) == "ebook" {
// 			result.BookType, err = q.CreateEBook(ctx, book.Boid)
// 			if err != nil {
// 				return err
// 			}
// 		} else {
// 			err = fmt.Errorf("book must have specific type: audiobook or ebook")
// 			return err
// 		}
// 		result.Category, err = q.CreateCategory(ctx, CreateCategoryParams{
// 			Boid:      book.Boid,
// 			Acategory: arg.Category,
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		result.Author, err = q.CreateAuthor(ctx, CreateAuthorParams{
// 			Boid:   book.Boid,
// 			Aather: arg.Author,
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// 	return result, err
// }